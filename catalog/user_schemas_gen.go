// Autogenerated code!
// DO NOT EDIT!
//
// Generated by UnsafeOrderedMap generator from the internal/cmd/generator command.

package catalog

import (
	"bytes"
	"encoding/json"

	"j/schema"
)

// Set sets a value with specified key.
func (m *UserSchemas) Set(k string, v jschema.Schema) {
	if m.data == nil {
		m.data = map[string]jschema.Schema{}
	}
	if !m.Has(k) {
		m.order = append(m.order, k)
	}
	m.data[k] = v
}

// Update updates a value with specified key.
func (m *UserSchemas) Update(k string, fn func(v jschema.Schema) jschema.Schema) {
	if !m.Has(k) {
		// Prevent from possible nil pointer dereference if map value type is a
		// pointer.
		return
	}

	m.data[k] = fn(m.data[k])
}

// GetValue gets a value by key.
func (m *UserSchemas) GetValue(k string) jschema.Schema {
	return m.data[k]
}

// Get gets a value by key.
func (m *UserSchemas) Get(k string) (jschema.Schema, bool) {
	v, ok := m.data[k]
	return v, ok
}

// Has checks that specified key is set.
func (m *UserSchemas) Has(k string) bool {
	_, ok := m.data[k]
	return ok
}

// Len returns count of values.
func (m *UserSchemas) Len() int {
	return len(m.data)
}

// Iterate iterates over map key/values.
// Will block in case of slow consumer.
// Should be used only for read only operations. Attempt to change something
// inside loop will lead to dead lock.
// Use UserSchemas.Map when you have to update value.
func (m *UserSchemas) Iterate() <-chan UserSchemasItem {
	ch := make(chan UserSchemasItem)
	go func() {
		for _, k := range m.order {
			ch <- UserSchemasItem{
				Key:   k,
				Value: m.data[k],
			}
		}
		close(ch)
	}()
	return ch
}

// Map iterates and changes values in the map.
func (m *UserSchemas) Map(fn mapUserSchemasFunc) error {
	for _, k := range m.order {
		v, err := fn(k, m.data[k])
		if err != nil {
			return err
		}
		m.data[k] = v
	}
	return nil
}

type mapUserSchemasFunc = func(k string, v jschema.Schema) (jschema.Schema, error)

// UserSchemasItem represent single data from the UserSchemas.
type UserSchemasItem struct {
	Key   string
	Value jschema.Schema
}

var _ json.Marshaler = &UserSchemas{}

func (m *UserSchemas) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteRune('{')

	for i, k := range m.order {
		if i != 0 {
			buf.WriteRune(',')
		}

		// marshal key
		key, err := json.Marshal(k)
		if err != nil {
			return nil, err
		}
		buf.Write(key)
		buf.WriteRune(':')

		// marshal value
		val, err := json.Marshal(m.data[k])
		if err != nil {
			return nil, err
		}
		buf.Write(val)
	}

	buf.WriteRune('}')
	return buf.Bytes(), nil
}
