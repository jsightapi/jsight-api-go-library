package main

import (
	"errors"
	"fmt"
	"go/ast"
	"path/filepath"
)

// setGenerator generator will search for `// gen:Set` comments for custom types
// and generate all necessary code to this type.
//
// Requirements:
// * Custom type should be a struct with exactly two fields: "data" anf "order";
// * Field "data" should be a map[T]struct{};
// * Field "order" should be a slice of map keys;
// * Field "mx" should a sync.RWMutex.
//
// Known limitations:
// * Unfortunately "omitempty" tag won't work as expected for set, so you should
//   add specific code for marshaling.

type setGenerator struct {
	byCommentGenerator
}

var _ generator = setGenerator{}

func newSetGenerator() setGenerator {
	g := setGenerator{}

	g.byCommentGenerator = newByCommentGenerator(
		"gen:Set",
		func(pkgName, path string, spec *ast.TypeSpec, _ map[string]string) error {
			strct, ok := spec.Type.(*ast.StructType)
			if !ok {
				return nil
			}

			if strct.Fields.NumFields() != 3 {
				//goland:noinspection GoErrorStringFormat
				return errors.New(`Set should have exactly three fields: "data", "order", and "mutex"`)
			}

			var (
				dataField  *ast.Field
				orderField *ast.Field
				mutexField *ast.Field
			)

			for _, f := range strct.Fields.List {
				switch f.Names[0].Name {
				case dataPropertyName:
					dataField = f

				case orderPropertyName:
					orderField = f

				case mutexPropertyName:
					mutexField = f
				}
			}

			s := set{
				PkgName: pkgName,
				Name:    spec.Name.Name,
			}

			if err := g.checkMutexField(mutexField); err != nil {
				return err
			}

			if err := g.collectSet(dataField, orderField, &s); err != nil {
				return err
			}

			if err := g.generateCode(s, filepath.Dir(path)); err != nil {
				return fmt.Errorf("failed to generate code for type %q: %w", s.Name, err)
			}

			return nil
		},
	)
	return g
}

func (setGenerator) checkMutexField(f *ast.Field) error {
	if f == nil {
		return errors.New(`"mutex" field didn't present'`)
	}

	se, ok := f.Type.(*ast.SelectorExpr)
	if !ok {
		return errors.New(`"mutex" field should be *sync.RWMutex`)
	}

	if x, ok := se.X.(*ast.Ident); !ok || x.Name != "sync" || se.Sel.Name != "RWMutex" {
		return errors.New(`"mutex" field should be *sync.RWMutex`)
	}

	return nil
}

type set struct {
	PkgName string
	Name    string
	Type    string
}

func (setGenerator) Name() string { return "Set" }

func (setGenerator) collectSet(data, order *ast.Field, s *set) error {
	mapType, ok := data.Type.(*ast.MapType)
	if !ok {
		return errors.New(`"data" field should be a map`)
	}

	var err error

	s.Type, err = typeToString(mapType.Key)
	if err != nil {
		return fmt.Errorf(`failed to get "data" map key type: %w`, err)
	}

	valueType, err := typeToString(mapType.Value)
	if err != nil {
		return fmt.Errorf(`failed to get "data" map value type: %w`, err)
	}

	if valueType != "struct{}" {
		return errors.New(`"data" map should have "struct{}" value type`)
	}

	slice, ok := order.Type.(*ast.ArrayType)
	if !ok {
		return errors.New(`"order" field should be a slice`)
	}

	sliceType, err := typeToString(slice.Elt)
	if err != nil {
		return fmt.Errorf(`failed to get "order" slice item type: %w`, err)
	}

	if sliceType != s.Type {
		return fmt.Errorf(
			`"order" slice item type %q isn't equal to %q`,
			sliceType,
			s.Type,
		)
	}

	return nil
}

func (setGenerator) generateCode(s set, dirPath string) error {
	const tmpl = `// Autogenerated code!
// DO NOT EDIT!
//
// Generated by Set generator from the internal/cmd/generator command.

package {{ .PkgName }}

func New{{ .Name }}(vv ...{{ .Type }}) *{{ .Name }} {
	data := make(map[{{ .Type }}]struct{}, len(vv))

	for _, v := range vv {
		data[v] = struct{}{}
	}

	return &{{ .Name }}{
		data: data,
		order: vv,
	}
}

// Add adds specific value to set.
func (m *{{ .Name }}) Add(v {{ .Type }}) {
	m.mx.Lock()
	defer m.mx.Unlock()

	if m.data == nil {
		m.data = map[{{ .Type }}]struct{}{}
	}
	if !m.has(v) {
		m.order = append(m.order, v)
	}
	m.data[v] = struct{}{}
}

// Has checks that specified value is exists.
func (m *{{ .Name }}) Has(v {{ .Type }}) bool {
	m.mx.RLock()
	defer m.mx.RUnlock()

	return m.has(v)
}

func (m *{{ .Name }}) has(v {{ .Type }}) bool {
	_, ok := m.data[v]
	return ok
}

// Len returns len of set.
func (m *{{ .Name }}) Len() int {
	m.mx.RLock()
	defer m.mx.RUnlock()

	return len(m.data)
}

// Data return set's data.
func (m *{{ .Name }}) Data() []{{ .Type }} {
	m.mx.RLock()
	defer m.mx.RUnlock()

	return m.order
}
`

	path := filepath.Join(dirPath, camelCaseToUnderscore(s.Name)+"_gen.go")
	return renderTemplateToFile(tmpl, path, s)
}
